<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy Pankaj — Auto-load GitHub Images</title>
<style>
  body{margin:0;font-family:Inter,Arial;background:#87CEEB;color:#222}
  .wrap{max-width:900px;margin:16px auto;padding:14px}
  header{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:20px}
  .card{background:#fff;border-radius:10px;padding:12px;box-shadow:0 8px 22px rgba(0,0,0,0.06);margin-top:12px}
  .drop{width:160px;height:120px;border:2px dashed rgba(0,0,0,0.08);border-radius:10px;display:flex;align-items:center;justify-content:center;flex-direction:column;cursor:pointer;background:rgba(255,255,255,0.6)}
  canvas#game{display:block;margin:14px auto;border-radius:8px;background:linear-gradient(#70c5ff,#a6e1ff)}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0b84ff;color:#fff;cursor:pointer}
  .muted{background:#eee;color:#333}
  .small{font-size:13px;color:#555}
  img.thumb{max-width:140px;max-height:100px;border-radius:6px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Flappy Pankaj — Auto-load images from GitHub</h1>
    <div class="small">Upload <code>bird.png</code> & <code>obstacle.png</code> to your repo root. The site will load them automatically.</div>
  </header>

  <div class="card">
    <div class="row">
      <div id="birdDrop" class="drop" title="Click to choose bird"><div id="birdPreview"><div class="small">Bird (100×100)</div></div></div>
      <div id="obsDrop" class="drop" title="Click to choose obstacle"><div id="obsPreview"><div class="small">Obstacle (80×400)</div></div></div>
      <div style="flex:1">
        <div class="small">Or use controls below — uploaded images (from repo) will override automatically.</div>
        <div style="margin-top:10px" class="row">
          <input id="birdFile" type="file" accept="image/*">
          <input id="obsFile" type="file" accept="image/*">
          <button id="clearBtn" class="muted">Clear Saved Images</button>
        </div>
      </div>
    </div>
  </div>

  <canvas id="game" width="480" height="720"></canvas>

  <div class="card row" style="justify-content:space-between;align-items:center">
    <div><strong>Score:</strong> <span id="score">0</span> &nbsp; <strong>Best:</strong> <span id="best">0</span></div>
    <div>
      <button id="startBtn">Start/Restart</button>
      <button id="pauseBtn" class="muted">Pause</button>
    </div>
  </div>
</div>

<script>
// ---------- Helpers ----------
function readFileAsImage(file){
  return new Promise((resolve,reject)=>{
    if(!file) return resolve(null);
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
    img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
    img.src = url;
  });
}
function resizeTo(img,w,h){
  const oc = document.createElement('canvas'); oc.width=w; oc.height=h;
  const c = oc.getContext('2d'); c.clearRect(0,0,w,h);
  const ar = img.width / img.height, arDst = w / h;
  let dw, dh;
  if(ar > arDst){ dh = h; dw = Math.round(h * ar); } else { dw = w; dh = Math.round(w / ar); }
  const dx = Math.round((w - dw) / 2), dy = Math.round((h - dh) / 2);
  c.drawImage(img, dx, dy, dw, dh);
  const out = new Image(); out.src = oc.toDataURL('image/png'); return out;
}
function showPreview(img, container){
  container.innerHTML = ''; if(!img) { container.innerHTML = '<div class="small">No image</div>'; return; }
  const el = document.createElement('img'); el.className='thumb'; el.src = img.src; container.appendChild(el);
}

// ---------- Elements ----------
const birdDrop = document.getElementById('birdDrop'), obsDrop = document.getElementById('obsDrop');
const birdFile = document.getElementById('birdFile'), obsFile = document.getElementById('obsFile');
const birdPreview = document.getElementById('birdPreview'), obsPreview = document.getElementById('obsPreview');
const clearBtn = document.getElementById('clearBtn');

const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// ---------- Sprites ----------
let birdSprite = null, obsSprite = null;
function createDefaultSprites(){
  const b = document.createElement('canvas'); b.width=100; b.height=100; const bc=b.getContext('2d');
  bc.clearRect(0,0,100,100); bc.fillStyle='#ffdd59'; bc.beginPath(); bc.arc(50,50,36,0,Math.PI*2); bc.fill();
  bc.fillStyle='#333'; bc.beginPath(); bc.arc(62,44,8,0,Math.PI*2); bc.fill(); const bi=new Image(); bi.src=b.toDataURL('image/png');
  const o = document.createElement('canvas'); o.width=80; o.height=400; const oc=o.getContext('2d');
  oc.fillStyle='#2f8f2f'; oc.fillRect(0,0,80,400); const oi=new Image(); oi.src=o.toDataURL('image/png');
  return { bi, oi };
}
const defaults = createDefaultSprites();
birdSprite = defaults.bi; obsSprite = defaults.oi;

// ---------- Try load from repo root (./bird.png and ./obstacle.png) ----------
function tryLoadFromRepoRoot(){
  // use relative paths so GitHub Pages serves them when they exist
  const b = new Image(); b.crossOrigin = 'anonymous'; b.onload = ()=>{ birdSprite = b; showPreview(b, birdPreview); localStorage.setItem('fp_bird_repo', location.origin + location.pathname.replace(/\/[^\/]*$/,'') + '/bird.png'); };
  b.onerror = ()=>{ /* missing on server; fallback handled elsewhere */ };
  b.src = './bird.png';

  const o = new Image(); o.crossOrigin = 'anonymous'; o.onload = ()=>{ obsSprite = o; showPreview(o, obsPreview); localStorage.setItem('fp_obs_repo', location.origin + location.pathname.replace(/\/[^\/]*$/,'') + '/obstacle.png'); };
  o.onerror = ()=>{ /* missing */ };
  o.src = './obstacle.png';
}
// call immediately
tryLoadFromRepoRoot();

// ---------- localStorage loader (fallback) ----------
function loadFromLocalStorage(){
  const bd = localStorage.getItem('fp_bird');
  const od = localStorage.getItem('fp_obs');
  const best = localStorage.getItem('fp_best');
  if(best) document.getElementById('best').textContent = parseInt(best,10);
  if(bd && !birdSprite) { const i=new Image(); i.onload=()=>{ birdSprite=i; showPreview(i,birdPreview); }; i.src=bd; }
  if(od && !obsSprite) { const i=new Image(); i.onload=()=>{ obsSprite=i; showPreview(i,obsPreview); }; i.src=od; }
}
loadFromLocalStorage();

// ---------- UI file handling ----------
async function handleFile(file,isBird){
  if(!file) return;
  try{
    const img = await readFileAsImage(file);
    if(isBird){
      const r = resizeTo(img,100,100);
      r.onload = ()=>{ birdSprite = r; showPreview(r, birdPreview); localStorage.setItem('fp_bird', r.src); localStorage.removeItem('fp_bird_repo'); };
    } else {
      const r = resizeTo(img,80,400);
      r.onload = ()=>{ obsSprite = r; showPreview(r, obsPreview); localStorage.setItem('fp_obs', r.src); localStorage.removeItem('fp_obs_repo'); };
    }
  }catch(err){ console.error(err); alert('Error reading file'); }
}
birdFile.addEventListener('change', e=> handleFile(e.target.files[0], true));
obsFile.addEventListener('change', e=> handleFile(e.target.files[0], false));
clearBtn.addEventListener('click', ()=>{
  localStorage.removeItem('fp_bird'); localStorage.removeItem('fp_obs'); localStorage.removeItem('fp_bird_repo'); localStorage.removeItem('fp_obs_repo');
  birdSprite = defaults.bi; obsSprite = defaults.oi; showPreview(birdSprite, birdPreview); showPreview(obsSprite, obsPreview);
  alert('Saved images cleared from this browser.');
});

// drag & click on boxes
function setupDrop(el, isBird){
  el.addEventListener('click', ()=> isBird ? birdFile.click() : obsFile.click());
  el.addEventListener('dragover', e=>{ e.preventDefault(); el.style.borderColor='#0b84ff'; });
  el.addEventListener('dragleave', ()=>{ el.style.borderColor=''; });
  el.addEventListener('drop', e=>{ e.preventDefault(); el.style.borderColor=''; const f = e.dataTransfer.files[0]; handleFile(f, isBird); });
}
setupDrop(birdDrop, true);
setupDrop(obsDrop, false);

// ---------- Simple Flappy Game (same mechanics) ----------
let bird = { x: Math.round(W*0.28), y: Math.round(H/2), r: 18, vy:0 };
let pipes = [], score = 0, best = parseInt(localStorage.getItem('fp_best')||0,10)||0;
document.getElementById('best').textContent = best;
let running=false, paused=false, frame=0;

function resetState(){ bird = { x: Math.round(W*0.28), y: Math.round(H/2), r: 18, vy:0 }; pipes=[]; score=0; frame=0; document.getElementById('score').textContent = 0; }
function spawnPipe(){ const gap = 150; const top = Math.floor(Math.random()*(H-gap-180))+40; pipes.push({x: W+30, top, gap, passed:false}); }
function drawBackground(){ ctx.fillStyle='#76c043'; ctx.fillRect(0,H-60,W,60); }
function drawBird(){ if(birdSprite && birdSprite.complete){ const size = 100 * (bird.r/18); ctx.save(); ctx.translate(bird.x,bird.y); const angle = Math.max(-0.7, Math.min(0.7, bird.vy/10)); ctx.rotate(angle); ctx.drawImage(birdSprite, -size/2, -size/2, size, size); ctx.restore(); } else { ctx.beginPath(); ctx.fillStyle='#ffdd59'; ctx.arc(bird.x,bird.y,bird.r,0,Math.PI*2); ctx.fill(); } }
function drawPipes(){ for(const p of pipes){ const w=80; if(obsSprite && obsSprite.complete){ ctx.drawImage(obsSprite, p.x, 0, w, p.top); ctx.drawImage(obsSprite, p.x, p.top + p.gap, w, H - (p.top + p.gap) - 60); } else { ctx.fillStyle='#2f8f2f'; ctx.fillRect(p.x,0,w,p.top); ctx.fillRect(p.x,p.top+p.gap,w,H-(p.top+p.gap)-60); } ctx.fillStyle='rgba(0,0,0,0.06)'; ctx.fillRect(p.x,p.top-6,w,6); } }
function circleRectCollide(cx,cy,r,rect){ const rx = Math.max(rect.x, Math.min(cx, rect.x+rect.w)); const ry = Math.max(rect.y, Math.min(cy, rect.y+rect.h)); const dx=cx-rx, dy=cy-ry; return (dx*dx + dy*dy) <= (r*r); }

function physicsStep(){ const gravity=0.7; bird.vy += gravity; bird.y += bird.vy; if(bird.y + bird.r > H-60) { bird.y = H-60-bird.r; bird.vy = 0; endGame(); } if(bird.y - bird.r < 0) { bird.y = bird.r; bird.vy = 0; } }
function checkCollision(){ for(const p of pipes){ const w=80; const topRect={x:p.x,y:0,w:w,h:p.top}; const botRect={x:p.x,y:p.top+p.gap,w:w,h:H-(p.top+p.gap)-60}; if(circleRectCollide(bird.x,bird.y,bird.r,topRect) || circleRectCollide(bird.x,bird.y,bird.r,botRect)) { endGame(); return; } if(!p.passed && (p.x + w) < bird.x) { p.passed = true; score++; document.getElementById('score').textContent = score; } } }
function endGame(){ running=false; document.getElementById('status') && (document.getElementById('status').textContent='Game Over'); const b = parseInt(localStorage.getItem('fp_best')||0,10)||0; if(score > b) { localStorage.setItem('fp_best', score); document.getElementById('best').textContent = score; } }
function update(){ if(!running || paused) return; frame++; if(frame % 90 === 0) spawnPipe(); for(let i=pipes.length-1;i>=0;i--){ pipes[i].x -= 3 + Math.min(6, score * 0.08); if(pipes[i].x + 90 < -60) pipes.splice(i,1); } physicsStep(); checkCollision(); }
function render(){ ctx.clearRect(0,0,W,H); drawBackground(); drawPipes(); drawBird(); }
function loop(){ update(); render(); if(running) requestAnimationFrame(loop); }
function flap(){ bird.vy = -10; }
window.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); if(!running) startGame(); flap(); } if(e.key==='p' || e.key==='P') togglePause(); });
canvas.addEventListener('click', ()=>{ if(!running) startGame(); flap(); });

function startGame(){ resetState(); running=true; paused=false; document.getElementById('status') && (document.getElementById('status').textContent='Playing'); requestAnimationFrame(loop); }
function togglePause(){ if(!running) return; paused = !paused; document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause'; }

// initial preview defaults
showPreview(birdSprite, birdPreview); showPreview(obsSprite, obsPreview);
spawnPipe(); spawnPipe(); render();
</script>
</body>
</html>
